package com.github.redxiiikk.spring.cloud.gateway.loadbalancer.isolation

import com.github.redxiiikk.spring.cloud.gateway.loadbalancer.isSingle
import com.github.redxiiikk.spring.cloud.gateway.loadbalancer.isolation.generator.EmptyLoadBalancerIsolationHeaderValueGenerator
import com.github.redxiiikk.spring.cloud.gateway.loadbalancer.isolation.generator.LoadBalancerIsolationHeaderValueGenerator
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.ObjectProvider
import org.springframework.cloud.gateway.filter.GatewayFilterChain
import org.springframework.cloud.gateway.filter.GlobalFilter
import org.springframework.cloud.gateway.filter.ReactiveLoadBalancerClientFilter
import org.springframework.core.Ordered
import org.springframework.http.HttpHeaders
import org.springframework.web.server.ServerWebExchange
import reactor.core.publisher.Mono


class LoadBalancerIsolationHeaderGeneratorFilter(
    private val property: LoadbalancerIsolationConfigProperty,
    private val generatorProvider: ObjectProvider<LoadBalancerIsolationHeaderValueGenerator>
) : GlobalFilter, Ordered {
    companion object {
        private val logger = LoggerFactory.getLogger(LoadBalancerIsolationHeaderGeneratorFilter::class.java)
    }

    /**
     * This filter must precede the loadBalancerFilter.
     */
    override fun getOrder(): Int = ReactiveLoadBalancerClientFilter.LOAD_BALANCER_CLIENT_FILTER_ORDER - 1

    override fun filter(exchange: ServerWebExchange, chain: GatewayFilterChain): Mono<Void> {
        return if (property.enable) {
            chain.filter(doIsolationHeaderValueGenerate(exchange))
        } else {
            chain.filter(exchange)
        }
    }

    private fun doIsolationHeaderValueGenerate(exchange: ServerWebExchange): ServerWebExchange {
        val request = exchange.request.mutate()
            .headers { headers ->
                val generator = generatorProvider.getIfAvailable { EmptyLoadBalancerIsolationHeaderValueGenerator() }
                val isolationHeaderValue = generator.generateHeaderValue(exchange)

                if (headers.needAddIsolationHeader(isolationHeaderValue)) {
                    logger.debug("the value generated by our policy should be added into the header.")
                    headers.add(property.isolationHeaderKey, isolationHeaderValue)
                }
            }
            .build()
        return exchange.mutate().request(request).build()
    }

    private fun HttpHeaders.needAddIsolationHeader(isolationHeaderValue: String): Boolean {
        if (this.containsKey(property.isolationHeaderKey)) {
            logger.debug("this request already has isolation header.")

            val headerValues = this[property.isolationHeaderKey]!!

            if (headerValues.isSingle()) {
                if (headerValues.single() == isolationHeaderValue) {
                    logger.debug("isolation header value is same as generated by our policy in this request.")
                }
            } else {
                logger.warn("header container too many value in this request.")

                if (headerValues.contains(isolationHeaderValue)) {
                    logger.debug("this header value contains that value generated by our policy in this request.")
                }
            }

            return false
        }
        return true
    }
}